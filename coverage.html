
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>calculator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">calculator/internal/calculator/service.go (95.2%)</option>
				
				<option value="file1">calculator/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package calculator

import (
        "errors"
        "io"
        "log/slog"
        "math"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// Request represents the calculator operation request
type Request struct {
        A float64 `json:"a" form:"a"`
        B float64 `json:"b" form:"b"`
}

// UnaryRequest represents the unary operation request
type UnaryRequest struct {
        A float64 `json:"a" form:"a"`
}

// Response represents the calculator operation response
type Response struct {
        Result float64 `json:"result"`
}

// Service handles calculator operations
type Service struct {
        Logger *slog.Logger
}

// logger returns a safe logger (never nil). If Logger is nil, returns a no-op logger.
func (s *Service) logger() *slog.Logger <span class="cov8" title="1">{
        if s.Logger != nil </span><span class="cov0" title="0">{
                return s.Logger
        }</span>
        <span class="cov8" title="1">return slog.New(slog.NewTextHandler(io.Discard, nil))</span>
}

// OperationFunc defines the signature for calculator operations
type OperationFunc func(a, b float64) (float64, error)

// UnaryOperationFunc defines the signature for unary operations
type UnaryOperationFunc func(a float64) (float64, error)

// Add handles addition operation
func (s *Service) Add(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.add)
}</span>

// AddGET handles addition operation via GET
func (s *Service) AddGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.add)
}</span>

// Subtract handles subtraction operation
func (s *Service) Subtract(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.subtract)
}</span>

// SubtractGET handles subtraction operation via GET
func (s *Service) SubtractGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.subtract)
}</span>

// Multiply handles multiplication operation
func (s *Service) Multiply(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.multiply)
}</span>

// MultiplyGET handles multiplication operation via GET
func (s *Service) MultiplyGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.multiply)
}</span>

// Divide handles division operation
func (s *Service) Divide(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.divide)
}</span>

// DivideGET handles division operation via GET
func (s *Service) DivideGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.divide)
}</span>

// Percentage handles percentage operation
func (s *Service) Percentage(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.percentage)
}</span>

// PercentageGET handles percentage operation via GET
func (s *Service) PercentageGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.percentage)
}</span>

// Power handles power operation
func (s *Service) Power(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.power)
}</span>

// PowerGET handles power operation via GET
func (s *Service) PowerGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.power)
}</span>

// Sqrt handles square root operation
func (s *Service) Sqrt(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.sqrt)
}</span>

// SqrtGET handles square root operation via GET
func (s *Service) SqrtGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.sqrt)
}</span>

// Root handles nth root operation
func (s *Service) Root(c *gin.Context) <span class="cov8" title="1">{
        s.handleOperation(c, s.root)
}</span>

// RootGET handles nth root operation via GET
func (s *Service) RootGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetOperation(c, s.root)
}</span>

// Inverse handles inverse operation
func (s *Service) Inverse(c *gin.Context) <span class="cov8" title="1">{
        s.handleUnaryOperation(c, s.inverse)
}</span>

// InverseGET handles inverse operation via GET
func (s *Service) InverseGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetUnaryOperation(c, s.inverse)
}</span>

// Negative handles negative operation
func (s *Service) Negative(c *gin.Context) <span class="cov8" title="1">{
        s.handleUnaryOperation(c, s.negative)
}</span>

// NegativeGET handles negative operation via GET
func (s *Service) NegativeGET(c *gin.Context) <span class="cov8" title="1">{
        s.handleGetUnaryOperation(c, s.negative)
}</span>

// handleOperation handles the common logic for all operations via POST
func (s *Service) handleOperation(c *gin.Context, op OperationFunc) <span class="cov8" title="1">{
        var req Request
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                s.logger().Error("Failed to bind JSON request", "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Info("Processing binary operation request", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", req.A, "b", req.B)

        result, err := op(req.A, req.B)
        if err != nil </span><span class="cov8" title="1">{
                s.logger().Error("Binary operation failed", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", req.A, "b", req.B, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Info("Binary operation successful", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", req.A, "b", req.B, "result", result)
        c.JSON(http.StatusOK, Response{Result: result})</span>
}

// handleGetOperation handles the common logic for all operations via GET
func (s *Service) handleGetOperation(c *gin.Context, op OperationFunc) <span class="cov8" title="1">{
        aStr := c.Query("a")
        bStr := c.Query("b")

        s.logger().Info("Processing binary operation GET request", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", aStr, "b", bStr)

        a, err := strconv.ParseFloat(aStr, 64)
        if err != nil </span><span class="cov8" title="1">{
                s.logger().Error("Failed to parse parameter 'a'", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", aStr, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid value for parameter 'a'"})
                return
        }</span>

        <span class="cov8" title="1">b, err := strconv.ParseFloat(bStr, 64)
        if err != nil </span><span class="cov8" title="1">{
                s.logger().Error("Failed to parse parameter 'b'", "operation", c.Request.URL.Path, "method", c.Request.Method, "b", bStr, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid value for parameter 'b'"})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Debug("Parsed binary operation GET parameters", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", a, "b", b)

        result, err := op(a, b)
        if err != nil </span><span class="cov8" title="1">{
                s.logger().Error("Binary operation GET failed", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", a, "b", b, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Info("Binary operation GET successful", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", a, "b", b, "result", result)
        c.JSON(http.StatusOK, Response{Result: result})</span>
}

// handleUnaryOperation handles the common logic for unary operations via POST
func (s *Service) handleUnaryOperation(c *gin.Context, op UnaryOperationFunc) <span class="cov8" title="1">{
        var req UnaryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                s.logger().Error("Failed to bind unary JSON request", "operation", c.Request.URL.Path, "method", c.Request.Method, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Info("Processing unary operation request", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", req.A)

        result, err := op(req.A)
        if err != nil </span><span class="cov8" title="1">{
                s.logger().Error("Unary operation failed", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", req.A, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Info("Unary operation successful", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", req.A, "result", result)
        c.JSON(http.StatusOK, Response{Result: result})</span>
}

// handleGetUnaryOperation handles the common logic for unary operations via GET
func (s *Service) handleGetUnaryOperation(c *gin.Context, op UnaryOperationFunc) <span class="cov8" title="1">{
        aStr := c.Query("a")

        s.logger().Info("Processing unary operation GET request", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", aStr)

        a, err := strconv.ParseFloat(aStr, 64)
        if err != nil </span><span class="cov8" title="1">{
                s.logger().Error("Failed to parse unary parameter 'a'", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", aStr, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid value for parameter 'a'"})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Debug("Parsed unary operation GET parameter", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", a)

        result, err := op(a)
        if err != nil </span><span class="cov8" title="1">{
                s.logger().Error("Unary operation GET failed", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", a, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">s.logger().Info("Unary operation GET successful", "operation", c.Request.URL.Path, "method", c.Request.Method, "a", a, "result", result)
        c.JSON(http.StatusOK, Response{Result: result})</span>
}

// Core operation implementations
func (s *Service) add(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing addition", "a", a, "b", b)
        result := a + b
        s.logger().Debug("Addition result", "result", result)
        return result, nil
}</span>

func (s *Service) subtract(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing subtraction", "a", a, "b", b)
        result := a - b
        s.logger().Debug("Subtraction result", "result", result)
        return result, nil
}</span>

func (s *Service) multiply(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing multiplication", "a", a, "b", b)
        result := a * b
        s.logger().Debug("Multiplication result", "result", result)
        return result, nil
}</span>

func (s *Service) divide(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing division", "a", a, "b", b)
        if b == 0 </span><span class="cov8" title="1">{
                s.logger().Error("Division by zero attempted", "a", a, "b", b)
                return 0, errors.New("cannot divide by zero")
        }</span>
        <span class="cov8" title="1">result := a / b
        s.logger().Debug("Division result", "result", result)
        return result, nil</span>
}

func (s *Service) percentage(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing percentage", "a", a, "b", b)
        result := a * (b / 100)
        s.logger().Debug("Percentage result", "result", result)
        return result, nil
}</span>

func (s *Service) power(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing power operation", "a", a, "b", b)
        result := math.Pow(a, b)
        s.logger().Debug("Power result", "result", result)
        return result, nil
}</span>

func (s *Service) sqrt(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing square root", "a", a)
        if a &lt; 0 </span><span class="cov8" title="1">{
                s.logger().Error("Square root of negative number attempted", "a", a)
                return 0, errors.New("cannot calculate square root of negative number")
        }</span>
        <span class="cov8" title="1">result := math.Sqrt(a)
        s.logger().Debug("Square root result", "result", result)
        return result, nil</span>
}

func (s *Service) root(a, b float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing nth root", "a", a, "b", b)
        if b == 0 </span><span class="cov8" title="1">{
                s.logger().Error("Zeroth root attempted", "a", a, "b", b)
                return 0, errors.New("cannot calculate 0th root")
        }</span>
        <span class="cov8" title="1">if a &lt; 0 </span><span class="cov8" title="1">{
                // Check if the root is odd (can handle negative numbers)
                if math.Mod(b, 2) == 1 </span><span class="cov8" title="1">{
                        // Odd root of negative number
                        s.logger().Debug("Performing odd root of negative number", "a", a, "b", b)
                        result := -math.Pow(-a, 1/b)
                        s.logger().Debug("Odd root of negative result", "result", result)
                        return result, nil
                }</span>
                <span class="cov8" title="1">s.logger().Error("Even root of negative number attempted", "a", a, "b", b)
                return 0, errors.New("cannot calculate even root of negative number")</span>
        }
        <span class="cov8" title="1">result := math.Pow(a, 1/b)
        s.logger().Debug("Nth root result", "result", result)
        return result, nil</span>
}

func (s *Service) inverse(a float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing inverse", "a", a)
        if a == 0 </span><span class="cov8" title="1">{
                s.logger().Error("Inverse of zero attempted", "a", a)
                return 0, errors.New("cannot calculate inverse of zero")
        }</span>
        <span class="cov8" title="1">result := 1 / a
        s.logger().Debug("Inverse result", "result", result)
        return result, nil</span>
}

func (s *Service) negative(a float64) (float64, error) <span class="cov8" title="1">{
        s.logger().Debug("Performing negation", "a", a)
        result := -a
        s.logger().Debug("Negation result", "result", result)
        return result, nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "log/slog"
        "net/http"
        "os"

        "calculator/internal/calculator"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

func main() <span class="cov0" title="0">{
        // Setup file logging
        logFile, err := os.OpenFile("calculator.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = logFile.Close()
        }</span>()

        // Create a file-based logger
        <span class="cov0" title="0">fileLogger := slog.New(slog.NewJSONHandler(logFile, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        }))

        // Set the default logger to also write to file (optional - for other packages)
        slog.SetDefault(fileLogger)

        // Create a new Gin router
        r := gin.Default()

        // Configure CORS middleware
        config := cors.DefaultConfig()
        config.AllowOrigins = []string{"http://localhost:3000"}
        config.AllowMethods = []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}
        config.AllowHeaders = []string{"Origin", "Content-Type", "Accept", "Authorization"}
        r.Use(cors.New(config))

        // Create calculator service with file logger
        calculatorService := &amp;calculator.Service{
                Logger: fileLogger,
        }

        // Setup routes
        setupRoutes(r, calculatorService)

        // Start the server
        port := ":8080"
        log.Printf("Server starting on port %s\n", port)
        log.Printf("Logging to file: calculator.log\n")
        if err := r.Run(port); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}

func setupRoutes(r *gin.Engine, s *calculator.Service) <span class="cov0" title="0">{
        // Health check endpoint
        r.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "ok"})
        }</span>)

        // Calculator endpoints
        <span class="cov0" title="0">api := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // POST endpoints
                api.POST("/add", s.Add)
                api.POST("/subtract", s.Subtract)
                api.POST("/multiply", s.Multiply)
                api.POST("/divide", s.Divide)
                api.POST("/percentage", s.Percentage)
                api.POST("/power", s.Power)
                api.POST("/sqrt", s.Sqrt)
                api.POST("/root", s.Root)
                api.POST("/inverse", s.Inverse)
                api.POST("/negative", s.Negative)

                // GET endpoints
                api.GET("/add", s.AddGET)
                api.GET("/subtract", s.SubtractGET)
                api.GET("/multiply", s.MultiplyGET)
                api.GET("/divide", s.DivideGET)
                api.GET("/percentage", s.PercentageGET)
                api.GET("/power", s.PowerGET)
                api.GET("/sqrt", s.SqrtGET)
                api.GET("/root", s.RootGET)
                api.GET("/inverse", s.InverseGET)
                api.GET("/negative", s.NegativeGET)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
